---
layout: page
title: Technical Guidelines
---
{% include JB/setup %}

{% include specsnav.html %}


<a id="encoding"></a>
<h3>Encoding and Field Formats</h3>

<ul>
  <li><a id="utf8"></a><b>Character encoding</b> must be in UTF-8</li>
  <li><a id="datetime"></a><b>DateTime and Date </b> fields will follow the ISO 8601 subset as per the <a href="http://www.w3.org/TR/NOTE-datetime">W3c note</a> except when specified otherwise</li>
  <li><a id="timezone"></a>When a <b>time zone</b> has to be specified explicitly (in an independent field), it should use a time zone name from the <a href="http://en.wikipedia.org/wiki/Tz_database">TZ Database</a></li>
  <li><a id="geospatial"></a><b>Geographical data</b> will follow existing standards:
    <ul>
      <li>In XML, geometrics will use <a href="http://en.wikipedia.org/wiki/Geography_Markup_Language">GML notation</a></li>
      <li>In JSON, the geometrics will use <a href="http://www.geojson.org/">GeoJSON notation</a></li>
    </ul>
  </li>
  <li><a id="links"></a><b>Links</b> will use the following rules</li>
  <ul>
    <li>In XML, links will use the <a href="http://tools.ietf.org/html/rfc4287">Atom link structure</a> and the IANA <a href="http://www.iana.org/assignments/link-relations/link-relations.xml">link relation list</a> where relevant</li>
    <li>In JSON, links will be regular attributes with their own names</li>
  </ul>
</ul>

<a id="rest"></a>
<h3>Restfulness</h3>

<p>Like most open data APIs, Open511 will follow the <a href="http://www.restapitutorial.com/lessons/whatisrest.html">REST design</a>. REST does not provide fixed constraints but best practices that will be used by the API:</p>
<ul>
  <li>Uniform interface: use of HTTP to provide uniform methods and content negotiation features</li>
  <li>Stateless: each request is independent from the previous one which simplifies implementation for both server and client</li>
  <li>Resource-based: each concept becomes a resource that can be accessed via an URL</li>
  <li>Hypermedia: representations contain links to other resources</li>
</ul>

<p>The Open511 specification, however, does not provide a fixed URL schema for the resources. The client should follow links between resources (starting from the <a href="root.html">discovery</a>) in order to retrieve the data.</p>

<a id="format"></a>
<h3>Response Format: XML and JSON</h3>

<p>In order to simplify integration in various contexts, Open511 supports two formats (or representations): XML and JSON. The client can specify the format they want to receive using the following options:</p>
<ul>
  <li>HTTP Header <code><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.1">Accept</a></code> specifying the type of representation accepted. Currently, the values accepted are <code>application/xml</code> and <code>application/json</code>. The server must answer with the appropriate <code>Content-Type</code> header.</li>
  <li>URL parameter <code>format</code> can also be used (and will override the HTTP header if both are present). Accepted values are <code>xml</code> and <code>json</code></li>
</ul>

<p>Each implementation is free to determine its default representation when the client does not specify which format is to be received.</p>

<p>&nbsp;</p>

<a id="xmlspec"></a>
<h4>XML specificities</h4>

<p>An XSD schema for the XML representation will be provided once the data structure is stabilized</p>


<ul><li>On top of namespaces, the Open511 container structure contains the version delivered
  <pre>&lt;open511 <b>version="v0"</b> xmlns:atom="http://www.w3.org/2005/Atom" ... &gt;</pre>
</li> 

<li>Resources should always have a self link, providing the current url, and a up link providing the url of the parent resource (except for the discovery resource which does not have any parent). These up and self link are directly located in the Open511 structure.
<pre>  &lt;open511 version="v0" ...&gt;
    &lt;atom:link rel="<b>self</b>" href="/api/jurisdictions/test/"/&gt;
    &lt;atom:link rel="<b>up</b>" href="/api/jurisdictions/"/&gt;
    ...
  &lt;/open511&gt;   </pre></li>

<li>Lists resources (like lists of events of reports) always contain a pagination block containing navigation info:<ul>
  <li><code>offset</code>: the starting offset of the current page.</li>
  <li><code>limit</code>: the maximum number of items to be listed in a response</li>
  <li><code>next</code>: a link to the next page of results if any</li>
  <li><code>previous</code>: a link to the previous page of results if any</li></ul>
    <pre>&lt;open511 ...&gt;
    ...
    &lt;pagination&gt;
      &lt;offset&gt;0&lt;/offset&gt;
      &lt;limit&gt;20&lt;/limit&gt;
      &lt;atom:link rel="next" href="/api/events/?limit=20&offset=20"/&gt;
    &lt;/pagination&gt;
  &lt;/open511&gt;</pre>
</li>

<li>In a list of first order (e.g <code>event</code> in the events resource) are directly embed in the open511 structure: 
    <pre>&lt;open511 ...&gt;
    &lt;event&gt;...&lt;/event&gt;
    &lt;event&gt;...&lt;/event&gt;
    &lt;event&gt;...&lt;/event&gt; 
    &lt;pagination&gt;...&lt;/pagination&gt;           
  &lt;/open511&gt;</pre>
</li>
<li>Lists included in a first order are included in a container structure: 
    <pre>&lt;open511 ...&gt;
    &lt;event&gt;
      ...
      <b>&lt;roads&gt;
        &lt;road&gt;...&lt;/road&gt;
        &lt;road&gt;...&lt;/road&gt;
      &lt;roads&gt;</b>        
    &lt;/event&gt;
  &lt;/open511&gt;</pre>
</li>

</ul>

<p>&nbsp;</p>
<a id="jsonspec"></a>
<h4>JSON specificities</h4>

<ul>
  <li>In XML, the links are using atom structure where possible. Since the atom structure does not exist in JSON, link will be declared as with a key <i>keyword</i>_url where keyword is the <code>rel</code> field in XML. For example
    <pre>&lt;atom:link rel="<b>description</b>" href="http://example.net/description.html"/&gt;</pre>
  becomes
    <pre>"<b>description</b>_url": "http://example.net/description.html"</pre></li>
  <li>For list resources, the content will be an array of items places in a <code>content</code> structure:
<pre>  {
    <b>"content": [</b>
        { "name" : "item1" ...},
        { "name" : "item2" ...}
    ]
  }</pre>       
</li> 
<li>For individual item, the content is directly in the first level structure</li>
<li>A <code>meta</code> structure has to be contained in each response. This <code>meta</code> structure contains the format version number as well as the self link (providing the current url) and the up link (providing the url of the parent ressource). The <code>meta</code> structure is contained directly in the first level structure.
<pre>  {
    ...
    "meta": {
        "version": "v0", 
        "up_url": "/api/events/mtq/",
        "self_url": "http://dev.open511.ca/api/events/mtq/maj39012/"
    }    
  }</pre></li>  

<li>Lists resources (like lists of events of reports) always contain a pagination block containing navigation info:<ul>
  <li><code>offset</code>: the starting offset of the current page.</li>
  <li><code>limit</code>: the maximum number of items to be listed in a response</li>
  <li><code>next</code>: a link to the next page of results if any</li>
  <li><code>previous</code>: a link to the previous page of results if any</li></ul>
  <pre>
  {
    ...
    "pagination": {
      "next_url": "/api/events/?limit=20&offset=20", 
      "limit": 20, 
      "previous_url": null, 
      "offset": 0
    }
  } </pre>
</li>

<li>Lists included in a first order are presented as an array: 
    <pre>
  {
    ...
    "roads": [
      { "name": "road1", ...},
      { "name": "road2", ...}
    ],
    ...
  }
</pre>
</li>
</ul>


<a id="bandwidth"></a>
<h3>Bandwidth Optimization and Conditional Requests</h3>

<p>Since the API will likely be used by mobile applications, bandwidth optimization is an important criteria. Clients and servers should support the following features:</p>

<ul>
  <li>Conditional request with <code><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.19">ETag</a></code> (for the server) and <code><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.26">If-None-Match</a></code> (for the client) HTTP headers. See <a href="http://developer.yahoo.com/performance/rules.html#etags">Configure ETags</a> and <a href="http://en.wikipedia.org/wiki/HTTP_ETag">Wikipedia</a>.</li>
  <li>Compression with HTTP header <code><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3">Accept-Encoding</a></code> and <code>Content-Encoding</code> is strongly encouraged</li>
</ul>

<a id="auth"></a>
<h3>Authentication and Encryption Mechanisms</h3>

<p>From an open data point of view, it is strongly encouraged that implementors make their API available for unauthenticated read access. For write access (e.g post <a href="report.html">reports</a>) or implementors wishing to have authentication features, this section presents how to manage it.</p>

<p>Encryption should be managed by the regular HTTP layer. The only encryption accepted is <a href="https://en.wikipedia.org/wiki/HTTP_Secure">HTTPS</a></p>

<p>For authentication, Open511 will work like many other APIs with an API key to be passed in a URL parameter <code>api_key</code>. When such authentication is implemented, it is strongly recommended to enable SSL/HTTPS in order to provide a protection of the API key</p>

<a id="lang"></a>
<h3>Response Language</h3>

<p>Open511 has the ability to support multiple languages. However, unilingual server implementations don't need to worry about anything here beyond ensuring that XML responses contain an appropriate <code>xml:lang</code> attribute. The negotiation of the language can be done in two ways:</p>
  <ul>
  <li>HTTP Header <code><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.4">Accept-Language</a></code> specifies the language the client would like to receive.
  <li>URL parameter <code>Accept-Language</code> can also be used (and will override the HTTP header if both are present) with the same values as the HTTP header.
</ul>

<p>In order to use the Accept-Language selector (either HTTP or URL parameter), the client provides a list of supported languages in order of priority. For example <code>pt, en</code> to get Portuguese before English. The language values accepted are specified in <a href="http://www.ietf.org/rfc/rfc1766.txt">RFC 1766</a>. For simpliciy, we recommend using the two-letter language-tag as defined by <a href="http://en.wikipedia.org/wiki/List_of_ISO_639-1_codes">ISO-639-1</a></p>

<p>The response will contain information about the language. In XML, the <code>xml:lang</code> will provide the language used for the answer. In JSON, a custom attribute <code>lang</code> will specify the language used, including for event lists in several language.</p>

<p>Mixed language within an event (some fields in one language, some fields in an other language) will not be supported. The XML representation should provide all the languages avaiable for all the fields when no <code>Accept-Language</code> is provided (either in HTTP or URL). In this case, each free-text field must contain a <code>xml:lang</code> attribute.</p>

<a id="aggreg"></a>
<h3>Aggregation and Multi-jurisdiction Endpoint</h3>

<p>The Open511 API is designed to support multi-jurisdiction endpoints (an endpoint that provides data for several jurisdictions) and aggregation of the content (an endpoint that gathers information from other endpoints). The last feature is meant to simplify the work of clients. For example a region can setup an aggregator for all the jurisdictions of the region, or a third party can build a service that serves a province or a country.</p>

<p>For the client, these features should be fairly transparent: endpoints will work the same way as described in the documentation. It is important to know that the jurisdiction links (in discovery and in events) must always point to the original resource (e.g, the original endpoint). This way, the client always has the opportunity to access the data of the original endpoint.</p>

<a id="cross"></a>
<h3>Cross domain requests</h3>

<p>In most cases, Open511 API implementations will have to serve cross-domain requests, when the client is not hosted on the server of the endpoint. As a consequence, the specification provides some rules for cross-domain request. Open511 intend to support both current methods for cross-domain requests:</p>
<ul>
  <li><a href="http://en.wikipedia.org/wiki/JSONP">JSONP</a>: provides a well-known cross-domain request feature working on a vast number of browsers. In order to provide an easy interoperability, the callback function should be named <code>callback</code>.<br/>Example: <code>...?callback=parameter</code></li>
  <li><a href="http://www.w3.org/TR/cors/">CORS</a>: offers a more standardized way of implementing cross-domain requests. Clients should prefer CORS when possible. Part of the CORS support, the implementation should include the following header:<br><code>Access-Control-Allow-Origin: *</code></li>
</ul>

<a id="custom"></a>
<h3>Custom fields</h3>
<p>Since some organizations might want to support some specific features within Open511 that are not part of the target of the specification. At the same time, a schema would still allow to have some validation (for the XML representation); the consequence of such schema is that custom fields would fail the validation. Custom fields must be added in a <code>extension</code> structure that could be added at any level of the data structure supported by Open511.</p>