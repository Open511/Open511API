---
layout: page
title: Technical Guidelines

pagination_spec : 
    - name: offset
      mandatory: Mandatory
      type: Integer
      desc: <p>The index within the full list of results, counting from 0, of the first result on the current page.</p><p>On the first page, <code>offset</code> will always be 0. If 20 results are shown per page, <code>offset</code> will be 20 on the second page, 40 on the third page, etc.</p>

    - name: next
      type: <a href="guidelines.html#links">Link</a>
      mandatory: Optional
      desc: <p>Link pointing to the next page of results. If omitted, implies that there is no next page.</p>

    - name: previous
      type: <a href="guidelines.html#links">Link</a>
      mandatory: Optional
      desc: <p>Link pointing to the previous page of results. If omitted, implies that there is no previous page, i.e. <code>offset</code> is 0.</p>      
---
{% include JB/setup %}

{% include specsnav.html %}


<a id="encoding"></a>
<h3>Encoding and Field Formats</h3>

<ul>
  <li><a id="utf8"></a><b>Character encoding</b> must be in UTF-8</li>
  <li><a id="datetime"></a><b>DateTime and Date </b> fields will follow the ISO 8601 subset as per the <a href="http://www.w3.org/TR/NOTE-datetime">W3c note</a> except when specified otherwise</li>
  <li><a id="timezone"></a>When a <b>time zone</b> has to be specified explicitly (in a <code>timezone</code> field, rather than as part of an ISO timestamp), it must use a time zone name from the <a href="http://en.wikipedia.org/wiki/Tz_database">TZ Database</a></li>
  <li><a id="geospatial"></a><b>Geospatial data</b> will follow existing standards, using the standard EPSG:4326 (latitude/longitude) spatial reference system:
    <ul>
      <li>In XML, use a <a href="#xmlgeo">subset of GML v2</a></li>
      <li>In JSON, use <a href="http://www.geojson.org/">GeoJSON</a></li>
    </ul>
  </li>
  <li><a id="links"></a><b>Links</b> will use the following rules</li>
  <ul>
    <li>In XML, links will use the a <code>link</code> tag. The syntax is as in <a href="http://tools.ietf.org/html/rfc4287">Atom</a>, though the tag is not placed within an Atom namespace. The type of link is in the <code>rel</code> attribute, and the URL in the <code>href</code> attribute.</li>
    <li>In JSON, as a rule, link attribute names have <code>_url</code> added to the end. There are some exceptions; see the JSON section below.</li>
  </ul>
</ul>

<a id="rest"></a>
<h3>REST</h3>

<p>Like many open data APIs, Open511 will roughly follow the <a href="http://www.restapitutorial.com/lessons/whatisrest.html">REST design</a>. REST does not provide fixed constraints but best practices that will be used by the API:</p>
<ul>
  <li>Uniform interface: use of HTTP to provide uniform methods and content negotiation features</li>
  <li>Stateless: each request is independent from the previous one which simplifies implementation for both server and client</li>
  <li>Resource-based: each concept becomes a resource that can be accessed via an URL</li>
  <li>Hypermedia: representations contain links to other resources</li>
</ul>

<p>The Open511 specification does not provide a fixed URL layout for the resources it describes. Resources are linked together (starting from the <a href="root.html">discovery</a> resource), and clients may follow these links to obtain the data they seek. For resources with an <code>id</code> field, it is a best practice to include this value in the resource URL, often as the final component of the path, so that the road event with ID <code>mycity.gov/52</code> has a URL at (for example) <code>/events/mycity.gov/52</code>.</p>

<a id="format"></a>
<h3>Format negotiation</h3>

<p>Open511 supports two serialization formats (XML and JSON). Implementations that wish to provide data in other formats may also do so via this mechanism.</p>

<p>Clients indicate their format preference via one of two mechanisms&colon;</p>

<ul>
  <li>The <code><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.1">Accept</a></code> HTTP header. The spec allows clients to list several possible content types in order of preference, though the simplest use of the header is to specify a single preferred type&colon; <code>Accept&colon; application/json</code>. Implementations must support the <code>application/json</code> and <code>application/xml</code> types.</li>
  <li>A URL parameter named <code>format</code>. It can accept a content type, as in the <code>Accept</code> HTTP header, as well as <code>?format=json</code> and <code>?format=xml</code>. If provided, it takes precedence over the <code>Accept</code> header.</li>
</ul>

<p>Implementations are free to determine their default serialization. Responses must include a <code>Content-Type</code> header set to the appropriate content type.</p>

<a id="versioning"></a>
<h3>Versioning</h3>

<p>Each major version of this specification is identified with a version string. The current version string is <code>v0</code>. When (and only when) a backwards-incompatible change is made to the specification, the version string will change.</p>

<p>Clients may request responses conforming to a specific Open511 version via one of two mechanisms&colon;</p>

<ul>
  <li>An <code>Open511-Version</code> header, with the desired version string as a value, e.g. <code>Open511-Version&colon; v1</code></li>
  <li>A URL parameter named <code>version</code>, e.g. <code>?version=v1</code>. If provided, it takes precedence over the <code>Open511-Version</code> header.</li>
</ul>

<p>When a client requests a version the server is unable to provide, the server may either respond using its default version, or may attempt to return the closest supported version to what the client is requesting; the specifics of this behaviour are left to implementors to decide.</p>

<a id="pagination"></a>
<h3>Pagination</h3>

<p>Endpoints returning lists of resources should be paginated. Page information is provided in a structure called <code>pagination</code> at the top level of the response&colon;</p>

  <table class="representation">
        <tr><th>Field</th><th>Type</th><th>Description</th></tr>
{% for item in page.pagination_spec %} 
   {% include tablegen.html %}
{% endfor %}   
     </table>

<p>Endpoints returning lists must also accept a <code>limit</code> URL parameter defining the maximum number of events to return in a single paginated response.</p>

<p>The default value for <code>limit</code> (how many items to include on a page if no parameter is provided) is up to individual implementors. Likewise, implementors may want to enforce a maximum value for this parameter in order to conserve server resources, so that a <code>?limit=10000</code> query would still return only e.g. 500 events per page. However, if such a maximum is implemented, it should not be lower than 500.</p>

<a id="serialization"></a>
<h3>Serialization</h3>

<p>Open511 supports XML and JSON serializations. The examples available on each resource page are usually the best way to understand the structure of the serializations; some non-exhaustive guidelines follow.</p>

<p>The examples available on each resource page are usually the best way to understand the structure of the serializations; some loose guidelines follow. A <a href="http://validator.open511.org/">web-based validator</a>, <a href="https://github.com/opennorth/open511-validator">commandline validation tool</a>, and <a href="https://github.com/opennorth/open511-validator/tree/master/open511_validator/schema">XML schema</a> are available to test the validity of your documents. As well, the <a href="http://validator.open511.org/">web validator</a> and <a href="https://github.com/opennorth/open511-validator">commandline tool</a> can convert between the XML and JSON serializations; this conversion tool may be useful for implementors who choose to store data in one serialization and convert on-demand to the other.</p>

<a id="xmlspec"></a>
<h4>XML</h4>

<ul><li>Documents are contained within an <code>open511</code> tag, which includes a version attribute:
  <pre>&lt;open511 <b>version="v0"</b> ... &gt;</pre>
</li> 

<li>Every response must contain a <code>self</code> link, providing the current url, and a <code>up</code> link providing the url of the parent resource (except for the discovery resource which does not have any parent). These <code>up</code> and <code>self</code> links are children of the <code>open511</code> tag.
{% highlight xml %}<open511 version="v0" ...>
    <link rel="<b>self</b>" href="/api/jurisdictions/test/"/>
    <link rel="<b>up</b>" href="/api/jurisdictions/"/>
    ...
  </open511>{% endhighlight %}</li>

<li>Objects generally appear within a container tag with a plural name: <code>event</code> within <code>events</code>, <code>area</code> within <code>areas</code>, etc.
{% highlight xml %}<open511 ...>
  <events>
    <event>...</event>
    <event>...</event>
  </events>
  <pagination>...</pagination>
  <link ... />
  <link ... />
</open511>{% endhighlight %}
</li>

<li>Links use a <code>link</code> tag, with the field name in the <code>rel</code> attribute and the URL in the <code>href</code> attribute: <code>&lt;link rel=&quot;self&quot; href=&quot;/api/events/&quot; /&gt;</code></li>

</ul>

<a id="xmlgeo"></a>
<h4>XML geographies</h4>

<p>Geospatial fields use <a href="http://en.wikipedia.org/wiki/Geography_Markup_Language">GML</a>. As this is a complex format, we use a small subset of GML v2.</p>

<p>All GML geometries must include the <code>srsName="EPSG:4326"</code> attribute. Coordinates are expressed using the <code>gml:coordinates</code> tag. Coordinates must be in <code>longitude,latitude</code> order, since despite great uncertainty over this topic x,y order remains more widely supported in software.</p>

<p>Open511 supports the following geometry structures:</p>

<ul>
  <li>{% highlight xml %}<gml:Point srsName="EPSG:4326">
  <gml:coordinates>-73.5877,45.5261</gml:coordinates>
</gml:Point>{% endhighlight %}</li>

<li>{% highlight xml %}<gml:LineString srsName="EPSG:4326">
  <gml:coordinates>-73.592,45.523 -73.59,45.524 -73.592,45.523</gml:coordinates>
</gml:LineString>{% endhighlight %}</li>

<li>{% highlight xml %}<gml:Polygon srsName="EPSG:4326">
  <gml:outerBoundaryIs>
    <gml:LinearRing>
      <gml:coordinates>-73,40 -73,41 -74,41 -74,40 -73,40</gml:coordinates>
    </gml:LinearRing>
  </gml:outerBoundaryIs>
  <gml:innerBoundaryIs>
    <gml:LinearRing>
      <gml:coordinates>-73.2,40.2 -73.2,40.8 -73.8,40.8 -73.8,40.2 -73.2,40.2</gml:coordinates>
    </gml:LinearRing>
  </gml:innerBoundaryIs>
</gml:Polygon>
<!-- note that most polygons will have only an outer boundary -->{% endhighlight %}</li>

<li>{% highlight xml %}<gml:MultiPoint srsName="EPSG:4326">
  <gml:pointMember>
    <gml:Point>
      <gml:coordinates>-73.5877,45.5261</gml:coordinates>
    </gml:Point>
  </gml:pointMember>
  <gml:pointMember>
    <gml:Point>
      <gml:coordinates>-73.6,45.4</gml:coordinates>
    </gml:Point>
  </gml:pointMember>
</gml:MultiPoint>{% endhighlight %}</li>

<li>MultiLineString and MultiPolygon geometries are similar, with <code>gml:lineStringMember</code> and <code>gml:polygonMember</code> tags</li>
</ul>

<p>&nbsp;</p>
<a id="jsonspec"></a>
<h4>JSON</h4>

<ul>
  <li>In XML, links use <code>&lt;link&gt;</code>. In JSON, links are generally normal attributes, but <code>_url</code> is appended to the field name (which is in the <code>rel</code> attribute in XML). For example
    <pre>&lt;link rel="<b>description</b>" href="http://example.net/description.html"/&gt;</pre>
  becomes
    <pre>"<b>description</b>_url": "http://example.net/description.html"</pre>
  But there are some exceptions:
  <ul>
    <li>Links with <code>rel="self"</code> are named simply <code>url</code> in JSON.</li>
    <li>In the <code>attachments</code> section of events, where links are expected to include several attributes, links are serialized as JSON objects.
      {% highlight xml %}<link rel="related" title="Detour map" type="application/pdf" length="200345" href="http://my.city.gov/trafic/advisory/39473/com.pdf" hreflang="en" />{% endhighlight %}
      becomes
{% highlight json %}{
  "type": "application/pdf",
  "length": 200345,
  "url": "http://my.city.gov/trafic/advisory/39473/com.pdf",
  "title": "Detour map",
  "hreflang": "en"
}{% endhighlight %}</li>
    <li>The <code>grouped_events</code> section of events is simply an array: <code>["/events/mycity.gov/4877", "/events/mycity.gov/8897"]</code></li>

  </ul>  
  </li>
<li>A <code>meta</code> structure has to be contained in each response. This <code>meta</code> structure contains the format version number as well as the self link (providing the current url) and the up link (providing the url of the parent ressource). The <code>meta</code> structure is contained directly in the first level structure.
{% highlight json %}{
  ...
  "meta": {
      "version": "v0", 
      "up_url": "/api/events/mtq/",
      "url": "/api/events/mtq/maj39012/"
  }    
}{% endhighlight %}</li>  


<li>Lists expressed in XML in a <code>&lt;things&gt;&lt;thing /&gt;&lt;/things&gt;</code> kind of structure are expressed via JSON arrays:
    
  {% highlight json %}{
  ...
  "events": [
    { "headline": "Road closed", ...},
    { "headline": "Bridge closed", ...}
  ],
  ...
}{% endhighlight %}

</li>
</ul>


<a id="bandwidth"></a>
<h3>Bandwidth Optimization and Conditional Requests</h3>

<p>Since the API will likely be used by mobile applications, bandwidth optimization is important. Servers are encouraged to support the following features:</p>

<ul>
  <li>Conditional requests, sending <code><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.19">ETag</a></code> in responses and accepting <code><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.26">If-None-Match</a></code> in requests. See <a href="http://developer.yahoo.com/performance/rules.html#etags">Configure ETags</a> and <a href="http://en.wikipedia.org/wiki/HTTP_ETag">Wikipedia</a>.</li>
  <li>GZip compression via <code><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3">Accept-Encoding</a></code> and <code>Content-Encoding</code></li>
</ul>

<a id="auth"></a>
<h3>Authentication and Encryption Mechanisms</h3>

<p>In the spirit of open data, we encourage implementors to make their API available for unauthenticated read access. For write access (e.g post <a href="report.html">reports</a>) or implementors who need to enforce authentication on GET requests, this section provides guidelines.</p>

<p>For authentication, users must use API keys (tokens). That token must be accepted via an <code>api_key</code> querystring parameter, because that&rsquo;s sometimes the only mechanism that works in-browser. However, because querystring authentication is awkward with hypermedia APIs like Open511 (links to other resources don&rsquo;t actually work until the client appends authentication parameters to the URL), implementations should also accept <a href="http://en.wikipedia.org/wiki/Basic_access_authentication">HTTP Basic authentication</a>, where the API key is provided as the username and the password is left blank.</p>

<p>Encryption should be managed by the regular HTTP layer. The only encryption accepted is <a href="https://en.wikipedia.org/wiki/HTTP_Secure">HTTPS</a>. Implementations using authentication are encouraged to enable (and perhaps require) HTTPS in order to protect API keys.</p>

<a id="errors"></a>
<h3>Error Handling</h3>

<p>When an error is encountered, the response must have a 4xx or 5xx HTTP error code. Specifically:</p>

<ul>
  <li>The client request is badly formed, e.g. incorrect filter syntax: <b>400</b></li>
  <li>The request requires authentication, but no API key was provided: <b>401</b>. The error message should explain how to obtain an API key.</li>
  <li>The request was for an individual resource URL, and that resource could not be found: <b>404</b>. Note that for an empty filtered list resource &mdash; e.g. all events with road_name <i>Boardwalk</i>, but no such events exist &mdash; the appropriate response is with status code 200 and an empty &lt;events /&gt; container within the standard response body.</li>
  <li>The server rate-limits requests, and the client has exceeded the rate limit: <b>429</b></li>
  <li>The server has an internal problem: <b>500</b></li>
</ul>

<p>Errors may be returned in <code>text/plain</code>, <code>application/xml</code>, or <code>application/json</code>. The minimum valid JSON error response is <code>{"error": "message here"}</code>. In XML, it's <code>&lt;open511 version=&quot;whatever&quot;&gt;&lt;error&gt;message here&lt;/error&gt;&lt;/open511&gt;</code>.</p>

<p>Implementors may choose to add additional fields on top of that minimum. For example, <code>{"error": "something bad happened", "internal_code": "HF8837"}</code>.</p>

<a id="lang"></a>
<h3>Response Language</h3>

<p>Open511 has the ability to support multiple languages. However, <strong>unilingual server implementations don't need to worry about anything here</strong> beyond ensuring that XML responses contain an appropriate <code>xml:lang</code> attribute.

<p>Clients may specify language preferences in one of two ways</p>
  <ul>
  <li>The <code><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.4">Accept-Language</a></code> HTTP header</li>
  <li>The <code>accept-language</code> URL parameter can also be used, using the same syntax as the header, e.g. <code>?accept-language=en,pt</code>. If provided, it takes precedence over the header.</li>
</ul>

<p>In order to use the Accept-Language selector (either HTTP or URL parameter), the client provides a list of supported languages in order of priority. For example <code>pt, en</code> to get Portuguese before English. The language values accepted are specified in <a href="http://www.ietf.org/rfc/rfc1766.txt">RFC 1766</a>. For simpliciy, we recommend using the two-letter language-tag as defined by <a href="http://en.wikipedia.org/wiki/List_of_ISO_639-1_codes">ISO-639-1</a></p>

<p>XML serializations must always contain <code>xml:lang</code> attributes to indicate the language(s) of the response. In XML, if no Accept-Language header or parameter is provided, then the server should return all the free-text data it knows about, regardless of language. This means that a single road event might contain <code>&lt;headline xml:lang="en"&gt;Bridge Replacement&lt;/headline&gt;&lt;headline xml:lang="fr"&gt;Remplacement du pont&lt;/headline&gt;</code>. If either an Accept-Language header or accept-language parameter are present, however, the server must select a single language for each object returned. Take the example of a client with a language preference of <code>fr, en</code> requesting a list of events, all of which are available in English and some of which are additionally available in French. The server should return French versions of the events where it can, and use English for the rest. However, within a single event, all the free-text fields returned should be in the same language.</p>

<p>When returning JSON data, the server must always select a single language for each object returned (as in the example above). In JSON, if no Accept-Language header or parameter is provided, the server must choose a single default language. Multilingual Open511 implementations should also add a <code>lang</code> attribute to each serialized object, with the ISO language tag as a value. Unilingual implementations do not need to include this attribute.</p>

<a id="aggreg"></a>
<h3>Aggregation and Multi-jurisdiction Endpoint</h3>

<p>The Open511 API is designed to support multi-jurisdiction endpoints (an endpoint that provides data for several jurisdictions) and aggregation of the content (an endpoint that gathers information from other endpoints). The last feature is meant to simplify the work of clients. For example, a region can setup an aggregator for all the jurisdictions of the region, or a third party can build a service that serves a province or a country.</p>

<p>Aggregators should not accept any client requests to modify aggregated data. Endpoints for aggregated data should accept only GET requests.</p>

<p>For the client, these features should be fairly transparent: endpoints will work the same way as described in the documentation. It is important to know that the jurisdiction links (in discovery and in events) must always point to the original resource (e.g, the original endpoint). This way, the client always has the opportunity to access the data of the original endpoint.</p>

<a id="cross"></a>
<h3>Cross domain requests</h3>

<p>Open511 APIs must support cross-domain requests, via both:</p>
<ul>
  <li><a href="http://en.wikipedia.org/wiki/JSONP">JSONP</a>, using a parameter named <code>callback</code>.<br/>Example: <code>...?callback=func_name</code></li>
  <li><a href="http://www.w3.org/TR/cors/">CORS</a>, by including an <code>Access-Control-Allow-Origin: *</code> header in all responses to GET queries</li>
</ul>

<a id="custom"></a>
<h3>Custom fields</h3>
<p>Some implementors might have specific requirements that aren&rsquo;t supported by the existing Open511 fields. While we encourage implementors to stay within the specification if possible, we also provide guidelines for adding custom fields to a specific implementation.</p>
<p>In XML serializations, custom tags may be placed anywhere, but must belong to a separate XML namespace, e.g. <code>&lt;bus_number xmlns=&quot;http://my.city.gov/open511-extensions&quot;&gt;</code>. In JSON serializations, custom attribute names must begin with <code>+</code>, e.g. <code>+bus_number</code>.</p>
