---
layout: page
title: Technical Guidelines
---
{% include JB/setup %}

{% include specsnav.html %}


<a id="encoding"></a>
<h3>Encoding and Field Formats</h3>

<ul>
  <li><a id="utf8"></a><b>Character encoding</b> must be in UTF-8</li>
  <li><a id="datetime"></a><b>DateTime and Date </b> fields will follow the ISO 8601 subset as per the <a href="http://www.w3.org/TR/NOTE-datetime">W3c note</a> except when specified otherwise</li>
  <li><a id="timezone"></a>When a <b>time zone</b> has to be specified explicitly (in an independent field), it should use a time zone name from the <a href="http://en.wikipedia.org/wiki/Tz_database">TZ Database</a></li>
  <li><a id="geospatial"></a><b>Geospatial data</b> will follow existing standards:
    <ul>
      <li>In XML, use <a href="http://en.wikipedia.org/wiki/Geography_Markup_Language">GML</a> with the EPSG:4326 (latitude/longitude) spatial reference system.</li>
      <li>In JSON, use <a href="http://www.geojson.org/">GeoJSON</a></li>
    </ul>
  </li>
  <li><a id="links"></a><b>Links</b> will use the following rules</li>
  <ul>
    <li>In XML, links will use the <a href="http://tools.ietf.org/html/rfc4287">Atom link tag</a>; the name of the link is placed in the <code>rel</code> attribute, and the URL in the <code>href</code> attribute.</li>
    <li>In JSON, as a rule, link attribute names have <code>_url</code> added to the end. There are some exceptions; see the JSON section below.</li>
  </ul>
</ul>

<a id="rest"></a>
<h3>Restfulness</h3>

<p>Like most open data APIs, Open511 will follow the <a href="http://www.restapitutorial.com/lessons/whatisrest.html">REST design</a>. REST does not provide fixed constraints but best practices that will be used by the API:</p>
<ul>
  <li>Uniform interface: use of HTTP to provide uniform methods and content negotiation features</li>
  <li>Stateless: each request is independent from the previous one which simplifies implementation for both server and client</li>
  <li>Resource-based: each concept becomes a resource that can be accessed via an URL</li>
  <li>Hypermedia: representations contain links to other resources</li>
</ul>

<p>The Open511 specification, however, does not provide a fixed URL schema for the resources. The client should follow links between resources (starting from the <a href="root.html">discovery</a>) in order to retrieve the data.</p>

<a id="format"></a>
<h3>Response Format: XML and JSON</h3>

<p>In order to simplify integration in various contexts, Open511 supports two formats (or representations): XML and JSON. The client can specify the format they want to receive using the following options:</p>
<ul>
  <li>HTTP Header <code><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.1">Accept</a></code> specifying the type of representation accepted. Currently, the values accepted are <code>application/xml</code> and <code>application/json</code>. The server must answer with the appropriate <code>Content-Type</code> header.</li>
  <li>URL parameter <code>format</code> can also be used (and will override the HTTP header if both are present). Accepted values are <code>xml</code> and <code>json</code></li>
</ul>

<p>Each implementation is free to determine its default representation when the client does not specify which format is to be received.</p>

<p>&nbsp;</p>

<a id="xmlspec"></a>
<h4>XML serialization</h4>

<p>An XSD schema for the XML representation will be provided once the data structure is stabilized</p>


<ul><li>The Open511 container tag includes a version attribute:
  <pre>&lt;open511 <b>version="v0"</b> xmlns:atom="http://www.w3.org/2005/Atom" ... &gt;</pre>
</li> 

<li>Resources should always have a <code>self</code> link, providing the current url, and a <code>up</code> link providing the url of the parent resource (except for the discovery resource which does not have any parent). These <code>up</code> and <code>self</code> link are directly located in the Open511 structure.
<pre>  &lt;open511 version="v0" ...&gt;
    &lt;atom:link rel="<b>self</b>" href="/api/jurisdictions/test/"/&gt;
    &lt;atom:link rel="<b>up</b>" href="/api/jurisdictions/"/&gt;
    ...
  &lt;/open511&gt;   </pre></li>

<li>List resources (like lists of events of reports) always contain a pagination block containing navigation info:<ul>
  <li><code>offset</code>: the starting offset of the current page.</li>
  <li><code>limit</code>: the maximum number of items to be listed in a response</li>
  <li><code>next</code>: a link to the next page of results if any</li>
  <li><code>previous</code>: a link to the previous page of results if any</li></ul>
    <pre>&lt;open511 ...&gt;
    ...
    &lt;pagination&gt;
      &lt;offset&gt;0&lt;/offset&gt;
      &lt;limit&gt;20&lt;/limit&gt;
      &lt;atom:link rel="next" href="/api/events/?limit=20&offset=20"/&gt;
    &lt;/pagination&gt;
  &lt;/open511&gt;</pre>
</li>

<li>In a list of first order (e.g <code>event</code> in the events resource) elements are directly embed in the open511 structure: 
    <pre>&lt;open511 ...&gt;
    &lt;event&gt;...&lt;/event&gt;
    &lt;event&gt;...&lt;/event&gt;
    &lt;event&gt;...&lt;/event&gt; 
    &lt;pagination&gt;...&lt;/pagination&gt;           
  &lt;/open511&gt;</pre>
</li>
<li>Lists included in a first order are included in a container structure: 
    <pre>&lt;open511 ...&gt;
    &lt;event&gt;
      ...
      <b>&lt;roads&gt;
        &lt;road&gt;...&lt;/road&gt;
        &lt;road&gt;...&lt;/road&gt;
      &lt;roads&gt;</b>        
    &lt;/event&gt;
  &lt;/open511&gt;</pre>
</li>

</ul>

<p>&nbsp;</p>
<a id="jsonspec"></a>
<h4>JSON serialization</h4>

<ul>
  <li>In XML, links use <code>&lt;atom:link&gt;</code>. In JSON, links are generally normal attributes, but <code>_url</code> is appended to the field name (which is in the <code>rel</code> attribute in XML). For example
    <pre>&lt;atom:link rel="<b>description</b>" href="http://example.net/description.html"/&gt;</pre>
  becomes
    <pre>"<b>description</b>_url": "http://example.net/description.html"</pre>
  But there are some exceptions:
  <ul>
    <li>Links with <code>rel="self"</code> are named simply <code>url</code> in JSON.</li>
    <li>In the <code>attachments</code> section of events, where links are expected to include several attributes, links are serialized as JSON objects.
      <pre>&lt;atom:link rel="related" title="Detour map" type="application/pdf" length="200345" href="http://my.city.gov/trafic/advisory/39473/com.pdf" /&gt;</pre>
      becomes
      <pre>{
    "type": "application/pdf",
    "size": 200345,
    "url": "http://my.city.gov/trafic/advisory/39473/com.pdf",
    "title": "Detour map"
}</pre></li>
    <li>The <code>grouped_events</code> section of events is simply an array: <code>["/events/mycity.gov/4877", "/events/mycity.gov/8897"]</code></li>

  </ul>  
  </li>
  <li>For list resources, the content will be an array of items under a <code>content</code> attribute:
<pre>  {
    <b>"content": [</b>
        { "name" : "item1" ...},
        { "name" : "item2" ...}
    ]
  }</pre>       
</li> 
<li>For individual item, the content is directly in the first level structure</li>
<li>A <code>meta</code> structure has to be contained in each response. This <code>meta</code> structure contains the format version number as well as the self link (providing the current url) and the up link (providing the url of the parent ressource). The <code>meta</code> structure is contained directly in the first level structure.
<pre>  {
    ...
    "meta": {
        "version": "v0", 
        "up_url": "/api/events/mtq/",
        "url": "/api/events/mtq/maj39012/"
    }    
  }</pre></li>  

<li>List resources (like lists of events of reports) always contain a pagination block containing navigation info:<ul>
  <li><code>offset</code>: the starting offset of the current page.</li>
  <li><code>limit</code>: the maximum number of items to be listed in a response</li>
  <li><code>next_url</code>: a link to the next page of results if any</li>
  <li><code>previous_url</code>: a link to the previous page of results if any</li></ul>
  <pre>
  {
    ...
    "pagination": {
      "next_url": "/api/events/?limit=20&offset=20", 
      "limit": 20, 
      "previous_url": null, 
      "offset": 0
    }
  } </pre>
</li>

<li>Lists included within an individual resource &mdash; structures like <code>&lt;roads&gt;&lt;road&gt; ...</code> in XML &mdash; also become arrays.
    <pre>
  {
    ...
    "roads": [
      { "name": "road1", ...},
      { "name": "road2", ...}
    ],
    ...
  }
</pre>
</li>
</ul>


<a id="bandwidth"></a>
<h3>Bandwidth Optimization and Conditional Requests</h3>

<p>Since the API will likely be used by mobile applications, bandwidth optimization is important. Servers should support the following features:</p>

<ul>
  <li>Conditional request with <code><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.19">ETag</a></code> (for the server) and <code><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.26">If-None-Match</a></code> (for the client) HTTP headers. See <a href="http://developer.yahoo.com/performance/rules.html#etags">Configure ETags</a> and <a href="http://en.wikipedia.org/wiki/HTTP_ETag">Wikipedia</a>.</li>
  <li>Compression with HTTP header <code><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3">Accept-Encoding</a></code> and <code>Content-Encoding</code> is strongly encouraged</li>
</ul>

<a id="auth"></a>
<h3>Authentication and Encryption Mechanisms</h3>

<p>From an open data point of view, it is strongly encouraged that implementors make their API available for unauthenticated read access. For write access (e.g post <a href="report.html">reports</a>) or implementors wishing to have authentication features, this section presents how to manage it.</p>

<p>Encryption should be managed by the regular HTTP layer. The only encryption accepted is <a href="https://en.wikipedia.org/wiki/HTTP_Secure">HTTPS</a>.</p>

<p>For authentication, Open511 will work like many other APIs with an API key to be passed in a URL parameter <code>api_key</code>. When such authentication is implemented, it is strongly recommended to enable SSL/HTTPS in order to protect the API key.</p>

<a id="lang"></a>
<h3>Response Language</h3>

<p>Open511 has the ability to support multiple languages. However, unilingual server implementations don't need to worry about anything here beyond ensuring that XML responses contain an appropriate <code>xml:lang</code> attribute.

<p>For multilingual implementations, language negotiation can be done in two ways:</p>
  <ul>
  <li>HTTP Header <code><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.4">Accept-Language</a></code> specifies the language the client would like to receive.
  <li>URL parameter <code>accept-language</code> can also be used (and will override the HTTP header if both are present) with the same values as the HTTP header.
</ul>

<p>In order to use the Accept-Language selector (either HTTP or URL parameter), the client provides a list of supported languages in order of priority. For example <code>pt, en</code> to get Portuguese before English. The language values accepted are specified in <a href="http://www.ietf.org/rfc/rfc1766.txt">RFC 1766</a>. For simpliciy, we recommend using the two-letter language-tag as defined by <a href="http://en.wikipedia.org/wiki/List_of_ISO_639-1_codes">ISO-639-1</a></p>

<p>The response will contain information about the language. In XML, the <code>xml:lang</code> will provide the language used for the answer. In JSON, a custom attribute <code>lang</code> will specify the language used, including for event lists in several language.</p>

<p>Mixed language within an event (some fields in one language, some fields in an other language) will not be supported. The XML representation should provide all the languages avaiable for all the fields when no <code>Accept-Language</code> is provided (either in HTTP or URL). In this case, each free-text field must contain a <code>xml:lang</code> attribute.</p>

<a id="aggreg"></a>
<h3>Aggregation and Multi-jurisdiction Endpoint</h3>

<p>The Open511 API is designed to support multi-jurisdiction endpoints (an endpoint that provides data for several jurisdictions) and aggregation of the content (an endpoint that gathers information from other endpoints). The last feature is meant to simplify the work of clients. For example a region can setup an aggregator for all the jurisdictions of the region, or a third party can build a service that serves a province or a country.</p>

<p>Aggregators should not accept any client requests to modify aggregated data. Endpoints for aggregated data should accept only GET requests.</p>

<p>For the client, these features should be fairly transparent: endpoints will work the same way as described in the documentation. It is important to know that the jurisdiction links (in discovery and in events) must always point to the original resource (e.g, the original endpoint). This way, the client always has the opportunity to access the data of the original endpoint.</p>

<a id="cross"></a>
<h3>Cross domain requests</h3>

<p>In most cases, Open511 API implementations will have to serve cross-domain requests, when the client is not hosted on the server of the endpoint. As a consequence, the specification provides some rules for cross-domain request. Open511 supports both current methods for cross-domain requests:</p>
<ul>
  <li><a href="http://en.wikipedia.org/wiki/JSONP">JSONP</a>: provides a well-known cross-domain request feature working on all browsers. In order to provide an easy interoperability, the callback function should be named <code>callback</code>.<br/>Example: <code>...?callback=parameter</code></li>
  <li><a href="http://www.w3.org/TR/cors/">CORS</a>: offers a more standardized way of implementing cross-domain requests. Open511 responses should include the following header:<br><code>Access-Control-Allow-Origin: *</code></li>
</ul>

<a id="custom"></a>
<h3>Custom fields</h3>
<p>Since some organizations might want to support some specific features within Open511 that are not part of the target of the specification. At the same time, a schema would still allow to have some validation (for the XML representation); the consequence of such schema is that custom fields would fail the validation. Custom fields must be added in a <code>extension</code> structure that could be added at any level of the data structure supported by Open511.</p>