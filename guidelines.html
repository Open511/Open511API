---
layout: page
title: Technical Guidelines
---
{% include JB/setup %}

{% include specsnav.html %}


<a id="encoding"></a>
<h3>Encoding and Field Formats</h3>

<ul>
  <li><a id="utf8"></a><b>Character encoding</b> must be in UTF-8</li>
  <li><a id="datetime"></a><b>DateTime and Date </b> fields will follow the ISO 8601 subset as per the <a href="http://www.w3.org/TR/NOTE-datetime">W3c note</a> except when specified otherwise</li>
  <li><a id="timezone"></a>When a <b>time zone</b> has to be specified explicitly (in a <code>timezone</code> field, rather than as part of an ISO timestamp), it must use a time zone name from the <a href="http://en.wikipedia.org/wiki/Tz_database">TZ Database</a></li>
  <li><a id="geospatial"></a><b>Geospatial data</b> will follow existing standards:
    <ul>
      <li>In XML, use <a href="http://en.wikipedia.org/wiki/Geography_Markup_Language">GML</a> with the EPSG:4326 (latitude/longitude) spatial reference system. <code><a href="https://github.com/opennorth/Open511API/issues/36">Issue 36</a></code></li>
      <li>In JSON, use <a href="http://www.geojson.org/">GeoJSON</a></li>
    </ul>
  </li>
  <li><a id="links"></a><b>Links</b> will use the following rules</li>
  <ul>
    <li>In XML, links will use the a <code>link</code> tag. The syntax is as in <a href="http://tools.ietf.org/html/rfc4287">Atom</a>, though the tag is not placed within an Atom namespace. The type of link is in the <code>rel</code> attribute, and the URL in the <code>href</code> attribute.</li>
    <li>In JSON, as a rule, link attribute names have <code>_url</code> added to the end. There are some exceptions; see the JSON section below.</li>
  </ul>
</ul>

<a id="rest"></a>
<h3>REST</h3>

<p>Like many open data APIs, Open511 will follow the <a href="http://www.restapitutorial.com/lessons/whatisrest.html">REST design</a>. REST does not provide fixed constraints but best practices that will be used by the API:</p>
<ul>
  <li>Uniform interface: use of HTTP to provide uniform methods and content negotiation features</li>
  <li>Stateless: each request is independent from the previous one which simplifies implementation for both server and client</li>
  <li>Resource-based: each concept becomes a resource that can be accessed via an URL</li>
  <li>Hypermedia: representations contain links to other resources</li>
</ul>

<p>The Open511 specification, however, does not provide a fixed URL schema for the resources. The client should follow links between resources (starting from the <a href="root.html">discovery</a>) in order to retrieve the data.</p>

<a id="format"></a>
<h3>Format and version negotation</h3>

<p>Open511 supports two serialization formats (XML and JSON), and includes mechanisms for dealing with future versions of the Open511 format. Format and version negotiation is done via content types.</p>

<p>Versions are each labelled with a string. Currently, <code>v0</code> is the only supported version of Open511.</p>

<p>The following content types are recognized:</p>

<ul>
  <li><code>application/xml</code></li>
  <li><code>application/json</code></li>
  <li><code>application/vnd.open511.v0+xml</code></li>
  <li><code>application/vnd.open511.v0+json</code></li>
</ul>

<p>The first two content types above are generic; requests for those indicate that the server should use the current default version of Open511. The latter two vendor-specific content types include a version string (<code>v0</code>).</p>

<p>Clients indicate their format preference via one of two mechanisms&colon;</p>

<ul>
  <li>The <code><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.1">Accept</a></code> HTTP header. The spec allows clients to list several possible content types in order of preference, though the simplest use of the header is to specify a single preferred type&colon; <code>Accept&colon; application/vnd.open511.v0+json</code></li>
  <li>A URL parameter named <code>format</code>. It can accept the same syntax as the <code>Accept</code> HTTP header; additionally, the special cases of <code>?format=json</code> and <code>?format=xml</code> request the current versions of either the JSON or XML serializations. If provided, it takes precedence over the <code>Accept</code> header.</li>
</ul>

<p>Implementations are free to determine their default serialization.</p>

<p>Responses must set the <code>Content-Type</code> header to the appropriate generic header&colon; <code>application/xml</code> or <code>application/json</code>. Responses must also set the <code>Open511-Media-Type</code> header to the vendor-specific, versioned content type of the response, e.g. <code>application/vnd.open511.v0+json</code>.</p>

<p>Versions are also indicated within the response content; see the XML and JSON sections below for details.</p>


<p>&nbsp;</p>

<a id="xmlspec"></a>
<h4>XML serialization</h4>

<p>A draft schema for the XML representation is <a href="https://github.com/opennorth/Open511API/tree/gh-pages/schema">available</a>.</p>


<ul><li>The Open511 container tag includes a version attribute:
  <pre>&lt;open511 <b>version="v0"</b> ... &gt;</pre>
</li> 

<li>Resources should always have a <code>self</code> link, providing the current url, and a <code>up</code> link providing the url of the parent resource (except for the discovery resource which does not have any parent). These <code>up</code> and <code>self</code> link are directly located in the Open511 structure.
<pre>  &lt;open511 version="v0" ...&gt;
    &lt;link rel="<b>self</b>" href="/api/jurisdictions/test/"/&gt;
    &lt;link rel="<b>up</b>" href="/api/jurisdictions/"/&gt;
    ...
  &lt;/open511&gt;   </pre></li>

<li>List resources (like lists of events of reports) always contain a pagination block containing navigation info:<ul>
  <li><code>offset</code>: the starting offset of the current page.</li>
  <li><code>next</code>: a link to the next page of results if any</li>
  <li><code>previous</code>: a link to the previous page of results if any</li></ul>
    <pre>&lt;open511 ...&gt;
    ...
    &lt;pagination&gt;
      &lt;offset&gt;0&lt;/offset&gt;
      &lt;link rel="next" href="/api/events/?limit=20&offset=20"/&gt;
    &lt;/pagination&gt;
  &lt;/open511&gt;</pre>
</li>

<li>In a list of first order (e.g <code>event</code> in the events resource) elements are directly embed in the open511 structure: 
    <pre>&lt;open511 ...&gt;
    &lt;event&gt;...&lt;/event&gt;
    &lt;event&gt;...&lt;/event&gt;
    &lt;event&gt;...&lt;/event&gt; 
    &lt;pagination&gt;...&lt;/pagination&gt;           
  &lt;/open511&gt;</pre>
</li>
<li>Lists included in a first order are included in a container structure: 
    <pre>&lt;open511 ...&gt;
    &lt;event&gt;
      ...
      <b>&lt;roads&gt;
        &lt;road&gt;...&lt;/road&gt;
        &lt;road&gt;...&lt;/road&gt;
      &lt;roads&gt;</b>        
    &lt;/event&gt;
  &lt;/open511&gt;</pre>
</li>

</ul>

<p>&nbsp;</p>
<a id="jsonspec"></a>
<h4>JSON serialization</h4>

<ul>
  <li>In XML, links use <code>&lt;link&gt;</code>. In JSON, links are generally normal attributes, but <code>_url</code> is appended to the field name (which is in the <code>rel</code> attribute in XML). For example
    <pre>&lt;link rel="<b>description</b>" href="http://example.net/description.html"/&gt;</pre>
  becomes
    <pre>"<b>description</b>_url": "http://example.net/description.html"</pre>
  But there are some exceptions:
  <ul>
    <li>Links with <code>rel="self"</code> are named simply <code>url</code> in JSON.</li>
    <li>In the <code>attachments</code> section of events, where links are expected to include several attributes, links are serialized as JSON objects.
      <pre>&lt;link rel="related" title="Detour map" type="application/pdf" length="200345" href="http://my.city.gov/trafic/advisory/39473/com.pdf" /&gt;</pre>
      becomes
      <pre>{
    "type": "application/pdf",
    "size": 200345,
    "url": "http://my.city.gov/trafic/advisory/39473/com.pdf",
    "title": "Detour map"
}</pre></li>
    <li>The <code>grouped_events</code> section of events is simply an array: <code>["/events/mycity.gov/4877", "/events/mycity.gov/8897"]</code></li>

  </ul>  
  </li>
  <li>For list resources, the content will be an array of items under a <code>content</code> attribute:
<pre>  {
    <b>"content": [</b>
        { "name" : "item1" ...},
        { "name" : "item2" ...}
    ]
  }</pre>       
</li> 
<li>For individual item, the content is directly in the first level structure</li>
<li>A <code>meta</code> structure has to be contained in each response. This <code>meta</code> structure contains the format version number as well as the self link (providing the current url) and the up link (providing the url of the parent ressource). The <code>meta</code> structure is contained directly in the first level structure.
<pre>  {
    ...
    "meta": {
        "version": "v0", 
        "up_url": "/api/events/mtq/",
        "url": "/api/events/mtq/maj39012/"
    }    
  }</pre></li>  

<li>List resources (like lists of events of reports) always contain a pagination block containing navigation info:<ul>
  <li><code>offset</code>: the starting offset of the current page.</li>
  <li><code>next_url</code>: a link to the next page of results if any</li>
  <li><code>previous_url</code>: a link to the previous page of results if any</li></ul>
  <pre>
  {
    ...
    "pagination": {
      "next_url": "/api/events/?limit=20&offset=20", 
      "previous_url": null, 
      "offset": 0
    }
  } </pre>
</li>

<li>Lists included within an individual resource &mdash; structures like <code>&lt;roads&gt;&lt;road&gt; ...</code> in XML &mdash; also become arrays.
    <pre>
  {
    ...
    "roads": [
      { "name": "road1", ...},
      { "name": "road2", ...}
    ],
    ...
  }
</pre>
</li>
</ul>


<a id="bandwidth"></a>
<h3>Bandwidth Optimization and Conditional Requests</h3>

<p>Since the API will likely be used by mobile applications, bandwidth optimization is important. Servers should support the following features:</p>

<ul>
  <li>Conditional requests, sending <code><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.19">ETag</a></code> in responses and accepting <code><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.26">If-None-Match</a></code> in requests. See <a href="http://developer.yahoo.com/performance/rules.html#etags">Configure ETags</a> and <a href="http://en.wikipedia.org/wiki/HTTP_ETag">Wikipedia</a>.</li>
  <li>GZip compression via <code><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3">Accept-Encoding</a></code> and <code>Content-Encoding</code> is strongly encouraged</li>
</ul>

<a id="auth"></a>
<h3>Authentication and Encryption Mechanisms</h3>

<p>From an open data point of view, it is strongly encouraged that implementors make their API available for unauthenticated read access. For write access (e.g post <a href="report.html">reports</a>) or implementors wishing to have authentication features, this section presents how to manage it.</p>

<p>Encryption should be managed by the regular HTTP layer. The only encryption accepted is <a href="https://en.wikipedia.org/wiki/HTTP_Secure">HTTPS</a>.</p>

<p>For authentication, Open511 will work like many other APIs with an API key to be passed in a URL parameter <code>api_key</code>. When such authentication is implemented, it is strongly recommended to enable SSL/HTTPS in order to protect the API key.</p>

<a id="lang"></a>
<h3>Response Language</h3>

<p>Open511 has the ability to support multiple languages. However, <strong>unilingual server implementations don't need to worry about anything here</strong> beyond ensuring that XML responses contain an appropriate <code>xml:lang</code> attribute.

<p>Clients may specify language preferences in one of two ways</p>
  <ul>
  <li>The <code><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.4">Accept-Language</a></code> HTTP header</li>
  <li>The <code>accept-language</code> URL parameter can also be used, using the same syntax as the header, e.g. <code>?accept-language=en,pt</code>. If provided, it takes precedence over the header.</li>
</ul>

<p>In order to use the Accept-Language selector (either HTTP or URL parameter), the client provides a list of supported languages in order of priority. For example <code>pt, en</code> to get Portuguese before English. The language values accepted are specified in <a href="http://www.ietf.org/rfc/rfc1766.txt">RFC 1766</a>. For simpliciy, we recommend using the two-letter language-tag as defined by <a href="http://en.wikipedia.org/wiki/List_of_ISO_639-1_codes">ISO-639-1</a></p>

<p>XML serializations must always contain <code>xml:lang</code> attributes to indicate the language(s) of the response. In XML, if no Accept-Language header or parameter is provided, then the server should return all the free-text data it knows about, regardless of language. This means that a single road event might contain <code>&lt;headline xml:lang="en"&gt;Bridge Replacement&lt;/headline&gt;&lt;headline xml:lang="fr"&gt;Remplacement du pont&lt;/headline&gt;</code>. If either an Accept-Language header or accept-language parameter are present, however, the server must select a single language for each object returned. Take the example of a client with a language preference of <code>fr, en</code> requesting a list of events, all of which are available in English and some of which are additionally available in French. The server should return French versions of the events where it can, and use English for the rest. However, within a single event, all the free-text fields returned should be in the same language.</p>

<p>When returning JSON data, the server must always select a single language for each object returned (as in the example above). In JSON, if no Accept-Language header or parameter is provided, the server must choose a single default language. Multilingual Open511 implementations should also add a <code>lang</code> attribute to each serialized object, with the ISO language tag as a value. Unilingual implementations do not need to include this attribute.</p>

<a id="aggreg"></a>
<h3>Aggregation and Multi-jurisdiction Endpoint</h3>

<p>The Open511 API is designed to support multi-jurisdiction endpoints (an endpoint that provides data for several jurisdictions) and aggregation of the content (an endpoint that gathers information from other endpoints). The last feature is meant to simplify the work of clients. For example, a region can setup an aggregator for all the jurisdictions of the region, or a third party can build a service that serves a province or a country.</p>

<p>Aggregators should not accept any client requests to modify aggregated data. Endpoints for aggregated data should accept only GET requests.</p>

<p>For the client, these features should be fairly transparent: endpoints will work the same way as described in the documentation. It is important to know that the jurisdiction links (in discovery and in events) must always point to the original resource (e.g, the original endpoint). This way, the client always has the opportunity to access the data of the original endpoint.</p>

<a id="cross"></a>
<h3>Cross domain requests</h3>

<p>Open511 APIs must support cross-domain requests, via both:</p>
<ul>
  <li><a href="http://en.wikipedia.org/wiki/JSONP">JSONP</a>, using a parameter named <code>callback</code>.<br/>Example: <code>...?callback=func_name</code></li>
  <li><a href="http://www.w3.org/TR/cors/">CORS</a>, by including an <code>Access-Control-Allow-Origin: *</code> header in all responses to GET queries</li>
</ul>

<a id="custom"></a>
<h3>Custom fields</h3>
<p>Some implementors might have specific requirements that aren&rsquo;t supported by the existing Open511 fields. While we encourage implementors to stay within the specification if possible, we also provide guidelines for adding custom fields to a specific implementation.</p>
<p>In XML serializations, custom tags may be placed anywhere, but must belong to a separate XML namespace. In JSON serializations, custom attribute names must begin with <code>+</code> (e.g. <code>+bus_number</code>).</p>
